<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Test Data Generation · AJD.jl</title><meta name="title" content="Test Data Generation · AJD.jl"/><meta property="og:title" content="Test Data Generation · AJD.jl"/><meta property="twitter:title" content="Test Data Generation · AJD.jl"/><meta name="description" content="Documentation for AJD.jl."/><meta property="og:description" content="Documentation for AJD.jl."/><meta property="twitter:description" content="Documentation for AJD.jl."/><meta property="og:url" content="https://muehlefeldt.github.io/AJD.jl/testdata_generation/"/><meta property="twitter:url" content="https://muehlefeldt.github.io/AJD.jl/testdata_generation/"/><link rel="canonical" href="https://muehlefeldt.github.io/AJD.jl/testdata_generation/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AJD.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../detailed-docs/">Detailed Docs</a></li><li><a class="tocitem" href="../theoretical-background/">Theory</a></li><li class="is-active"><a class="tocitem" href>Test Data Generation</a><ul class="internal"><li><a class="tocitem" href="#Continous-signals"><span>Continous signals</span></a></li><li><a class="tocitem" href="#Discrete-signals"><span>Discrete signals</span></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Test Data Generation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Test Data Generation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/muehlefeldt/AJD.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/muehlefeldt/AJD.jl/blob/master/docs/src/testdata_generation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Generating-(time-correlated)-matrices"><a class="docs-heading-anchor" href="#Generating-(time-correlated)-matrices">Generating (time correlated) matrices</a><a id="Generating-(time-correlated)-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-(time-correlated)-matrices" title="Permalink"></a></h1><p>The function <code>AJD.generate_testdata</code> is currently not exported but will give you the opportunity to create your own testsets to be diagonalized, consisting of an implementation of time delayed correlation matrices. The implementation of the time delayed correlation matrices used are explained <a href="https://publishup.uni-potsdam.de/opus4-ubp/frontdoor/deliver/index/docId/501/file/ziehe.pdf">here (p.16)</a>.</p><p>If you just want to start with generating data to be diagonalized currently the recommended way is either to use the code:</p><pre><code class="language-julia hljs">data = AJD.get_test_data(:approx_diag_large, 10, 10)
filter_ = diagonalize(data)</code></pre><p>which takes a waveform file part of the repository (<code>channels3_room69_mix.wav</code>) and reads the audio data from the file, which consists of three different audio signals mixed together and diagonalizes the set of matrices or the code</p><pre><code class="language-julia hljs">data = AJD.get_test_data(:exact_diag, 10, 10)
filter_ = diagonalize(data)</code></pre><p>with data being a random set of normal commuting matrices with dimension <code>n_dim</code> <span>$\times$</span> <code>n_dim</code> <span>$\times$</span> <code>n_matrices</code>.</p><p>The first way is essentially the same as writing:</p><pre><code class="language-julia hljs">using WAV
data,_ = wavread(&quot;test_data/channels3_room69_mix.wav&quot;)
#data needs to be transposed since wavread concatenates signals columnwise
data = data&#39; 
using AJD
#no_of_segments is always one more than n_matrices
testset_data = AJD.generate_testdata(data, delay = 1000,no_of_segments=11,show_warning = false)
filter_ = diagonalize(testset_data)</code></pre><p>however the code above is a bit more versatile since delay can be adjusted and the warning message for wrong segmentation can be enabled.</p><p>Another way to generate a testset of correlation matrices from random vectors is provided with:</p><pre><code class="language-julia hljs">using AJD
#you can adjust this!
no_of_signals,no_of_samples = (10,1000)
# also includes a seed and signal_type (either Float64 or ComplexF64)
signals = AJD.generate_random_signals(no_of_signals,no_of_samples)
testset_data = AJD.generate_testdata(signals, delay = 100,no_of_segments=11,show_warning = false)
filter_ = diagonalize(testset_data)</code></pre><p>which generates random time correlated matrices.</p><p>For more advanced testdata generation the following might be interesting.</p><p>There are currently two other ways to generate your own testdata, either using discrete or continous signals. The method for discrete testdata is used in the first example code. Continous signals are not the recommended way to implement testdata but is theoretically possible and was inspired by <a href="https://doi.org/10.21595/jve.2021.21961 p.1709">Zhang,Xin2021</a>.</p><h2 id="Continous-signals"><a class="docs-heading-anchor" href="#Continous-signals">Continous signals</a><a id="Continous-signals-1"></a><a class="docs-heading-anchor-permalink" href="#Continous-signals" title="Permalink"></a></h2><p>The function </p><pre><code class="language-julia hljs">AJD.generate_testdata(signal_sources::AbstractArray{&lt;:Function}, 
mixing_matrix::AbstractMatrix{&lt;:Number}; delay::Number = 1, sample_time::Number = 10, 
no_of_samples::Int = 100, no_of_cor::Int = 10)</code></pre><p>for continous signals is a bit convoluted to be honest. The input <code>signal_sources</code> is an array of anonymous function like:</p><pre><code class="language-julia hljs"># similiar signals to signals found in https://doi.org/10.21595/jve.2021.21961 p.1709
signal_sources = [t-&gt;1.6sin(2pi*5t+5)+2sin(2pi*20t+27)+0.5sin(2pi*100t)+1 , t-&gt;1.2(2pi*11t)+sin(2pi*2t)+0.7sin(2pi*111t+10)]</code></pre><p>and relates to the unmixed signal used in BSS problems. For more information on BSS problems see: <a href="https://publishup.uni-potsdam.de/opus4-ubp/frontdoor/deliver/index/docId/501/file/ziehe.pdf">Ziehe (p.5 ff.)</a>.</p><p>Source Signals are time dependent functions, but for <strong>testing purposes only</strong> do not necessarily only have to consist of harmonic functions and could include <span>$t^{t}$</span>. </p><p>Be careful though with choosing functions since if the variance of the signal becomes zero for long times the correlation matrix will include NaN values!</p><p>The input <code>mixing_matrix</code> can be a random matrix, the only constraint being that it has to have the same column size as signals in the source signals vector. Otherwise the calculation of the measurements/observations <span>$x_i = \sum_{j=1}^m A_{ij}s_j(t)$</span> won&#39;t be possible. (For further information about calculation of the measurements see <a href="https://publishup.uni-potsdam.de/opus4-ubp/frontdoor/deliver/index/docId/501/file/ziehe.pdf">Ziehe (p.6 ff.)</a>)</p><pre><code class="language-julia hljs"># mixing matrix is the same as in https://doi.org/10.21595/jve.2021.21961 p.1709
mixing_matrix =  [0.32 -0.43; -1.31 0.34]</code></pre><p>The measurements are used for calculating the time delayed correlation matrices <span>$C^k$</span> The argument <code>sample_time</code> is used as the ending time of the signal in seconds and <code>no_of_samples</code> is the frequency/sampletime of the signal.</p><p><code>no_of_cor</code> is used as an indicator how many time delayed correlation matrices are to be calculated.</p><p>The argument <code>delay</code> is used to indicate the time shift between two observations <span>$x(t)$</span> and <span>$x(t+\tau)$</span>.</p><h3 id="Example-continous-signal"><a class="docs-heading-anchor" href="#Example-continous-signal">Example continous signal</a><a id="Example-continous-signal-1"></a><a class="docs-heading-anchor-permalink" href="#Example-continous-signal" title="Permalink"></a></h3><pre><code class="language-julia hljs">using AJD
signal_sources = [x-&gt;1.6sin(2pi*5x+5)+2sin(2pi*20x+27)+0.5sin(2pi*100x)+1,x-&gt;1.2(2pi*11x)+sin(2pi*2x)+0.7sin(2pi*111x+10)]
mixing_matrix = [0.32 -0.43; -1.31 0.34]
testset_data = AJD.generate_testdata(signal_sources,mixing_matrix)
diagonalize(testset_data)</code></pre><h2 id="Discrete-signals"><a class="docs-heading-anchor" href="#Discrete-signals">Discrete signals</a><a id="Discrete-signals-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-signals" title="Permalink"></a></h2><p>For realising discrete test data the files <code>channels2_room69_mix.wav</code>, <code>channels3_room69_mix.wav</code> and  <code>channels3_room69_mix_shortened.wav</code> are included in the repository. </p><p>The data was generated using the github code found <a href="https://github.com/fakufaku/bss_speech_dataset">here</a>. The function </p><pre><code class="language-julia hljs">generate_testdata(signal_sources::AbstractArray; delay::Number = 10, no_of_segments::Int = 10)</code></pre><p>behaves differently for discrete signals than the continous counterpart.</p><p><code>signal_sources</code> is a matrix with the observations <span>$x_i(t)$</span> ordered rowwise [<span>$x_1(t)$</span>; <span>$x_2(t)$</span>; <span>$x_3(t)$</span>].</p><p><code>delay</code> is the shift index by which the time delay is emulated. <code>delay</code>= 1000 means x[<code>curr_column</code> + 1000].</p><p><code>no_of_segments</code> divides the <code>signal_sources</code> into even segments to be correlated. </p><p>Future implementation could also include the keyword <code>points_per_segment</code>, which will behave similar to <code>sample_time</code> of the analog counterpart, to be more intuitive. However that could mean (especially if the size of data is not known beforehand) that calculations could take a while.</p><p>If the segments are not equally divided the method will throw an error. Make sure the length of the observations is dividable by the number of segments or trim your data to be able to!</p><h3 id="Example-discrete-signal"><a class="docs-heading-anchor" href="#Example-discrete-signal">Example discrete signal</a><a id="Example-discrete-signal-1"></a><a class="docs-heading-anchor-permalink" href="#Example-discrete-signal" title="Permalink"></a></h3><pre><code class="language-julia hljs">using WAV
data,fs = wavread(&quot;test_data/channels3_room69_mix.wav&quot;)
#currently needed since observations are inside columns
data = data&#39; 
using AJD
testset_data = AJD.generate_testdata(data, delay = 1000,no_of_segments=6)
diagonalize(testset_data)

using WAV
data,fs = wavread(&quot;test_data/channels2_room69_mix.wav&quot;)
#currently needed since observations are inside columns
data = data&#39; 
using AJD
#data has size 2x320336 which is why slicing is used
testset_data = AJD.generate_testdata(data[:,1:320300], delay = 1000,no_of_segments=100)
diagonalize(testset_data)</code></pre><h3 id="Generating-testset-from-[https://github.com/fakufaku/bss*speech*dataset](https://github.com/fakufaku/bss_speech_dataset)"><a class="docs-heading-anchor" href="#Generating-testset-from-[https://github.com/fakufaku/bss*speech*dataset](https://github.com/fakufaku/bss_speech_dataset)">Generating testset from <a href="https://github.com/fakufaku/bss_speech_dataset">https://github.com/fakufaku/bss<em>speech</em>dataset</a></a><a id="Generating-testset-from-[https://github.com/fakufaku/bss*speech*dataset](https://github.com/fakufaku/bss_speech_dataset)-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-testset-from-[https://github.com/fakufaku/bss*speech*dataset](https://github.com/fakufaku/bss_speech_dataset)" title="Permalink"></a></h3><p>If you want to generate your own test data or additional datasets refer to the github repository linked above and clone it. You&#39;ll need python!</p><p>For the code of the repo to work the following adaptations have to be made:</p><ul><li>the generate_samples.py has to be changed on line 120. Change the deprecated <code>np.float</code>to <code>float</code></li></ul><p>The generation will take a while and (<em>probably</em>) uses around 10GB of storage space. You can always cancel the generation of testdata during the process and get some testsets generated until then. After generating your testset you might want to edit the soundfiles since some of the testsets have </p><h3 id="Known-Issues"><a class="docs-heading-anchor" href="#Known-Issues">Known Issues</a><a id="Known-Issues-1"></a><a class="docs-heading-anchor-permalink" href="#Known-Issues" title="Permalink"></a></h3><p>The discrete case won&#39;t work if one of the segments is a vector of only zeros, since the correlation of this vector will become NaN due to the variance being zero! The function will throw an error in that case!</p><p>Make sure to decrease number of segments or if added increase the number of points per segment.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theoretical-background/">« Theory</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 29 January 2025 18:00">Wednesday 29 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
