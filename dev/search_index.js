var documenterSearchIndex = {"docs":
[{"location":"detailed-docs/#Detailed-Docs","page":"Detailed Docs","title":"Detailed Docs","text":"","category":"section"},{"location":"detailed-docs/","page":"Detailed Docs","title":"Detailed Docs","text":"","category":"page"},{"location":"detailed-docs/","page":"Detailed Docs","title":"Detailed Docs","text":"Modules = [AJD]","category":"page"},{"location":"detailed-docs/#AJD.ALL_ALGORITHMS","page":"Detailed Docs","title":"AJD.ALL_ALGORITHMS","text":"List of all algorithms. To loop over in tests.\n\n\n\n\n\n","category":"constant"},{"location":"detailed-docs/#AJD.addrandomnoise-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T<:Number, M<:AbstractMatrix{T}}","page":"Detailed Docs","title":"AJD.addrandomnoise","text":"addrandomnoise(\n    A::Vector{M};\n    σ::AbstractFloat = 0.5,\n    same_noise::Bool = true,\n) where {T<:Number,M<:AbstractMatrix{T}}\n\nAdd ranom noise to a vector of matrices A. If same noise selected same random matrix R used for all (!) matrices. Completley random noise added to each matrix in A with same_noise=false.\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.check_input-Tuple{Vector{<:AbstractMatrix{<:Number}}, Int64, AbstractFloat}","page":"Detailed Docs","title":"AJD.check_input","text":"check_input(\n    A::Vector{<:AbstractMatrix{<:Number}},\n    max_iter::Int,\n    threshold::AbstractFloat,\n    )\n\nCheck input of diagonalize(). Validate matrices, threshold and max iteration as selected.\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.create_linear_filter-Tuple{Matrix{T} where T<:Number}","page":"Detailed Docs","title":"AJD.create_linear_filter","text":"Create LinearFilter object as introduced by Diagonalizations.jl. Output of AJD.jl follows convention of Diagonalizations.jl and produces a LinearFilter.\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.diagonalize-Tuple{Vector{<:AbstractMatrix{<:Number}}}","page":"Detailed Docs","title":"AJD.diagonalize","text":"(1)\n    diagonalize(\n        M::Vector{<:AbstractMatrix{<:Number}};\n        algorithm::AbstractDiagonalization = JDiagEdourdPineau(),\n        max_iter::Int = 1000,\n        threshold::AbstractFloat = eps())\n\n\n    (2) diagonalize(\n        M::Vector{<:AbstractMatrix{<:Number}},\n        only_plot::Symbol;\n        algorithm::AbstractDiagonalization = JDiagGabrielDernbach(),\n        max_iter::Int = 1000,\n        threshold::AbstractFloat = eps())\n\n\n    (3) diagonalize(\n        benchmark::Symbol,\n        n_dims::Int,\n        n_matrices::Int)\n\nCalculate joint diagonalization of multiple input matrices M_k.\n\nMain function of the AJD package. Implemented algorithms are JDiag and FFDiag. Input of matrices M_k need to be a vector of matrices. The matrices can be of types Float64 or Complex.\n\nSee the Getting Started Guide for information on the algorithms.\n\nDispatch (1)\n\nInputs:\n\nM: Vector of matrices (requiered).\nalgorithm: Selected algorithm from JDiagGabrielDernbach(), JDiagEdourdPineau(), JDiagCardoso() or FFDiag().\nmax_iter: Maximum iteration step as integer.\nthreshold: Desired threshold minimizing the off-diagonal elements.\n\nOutput:\n\nReturn LinearFilter object. Filter fil contains filter matrix fil.F and the inverse fil.iF.\n\nDispatch (2) - Benchmark Extension to AJD.jl\n\nInputs:\n\nAdditional symbol used to generate overview plot of the result. Use diagonalize(M, :plot).\n\nOutput:\n\nOverview plot. Shows heatmap of the filter matrix, heatmap of the mean of the diagonalized matrices and the vonvergence behaviour of the algorithm.\n\nDispatch (3) - Benchmark Extension to AJD.jl\n\nInputs:\n\nSymbol :benchmark used as diagonalize(:benchmark, 10, 10).\nAutomatic benchmark is run comparing JDiag and FFDiag algorithms. Using n_dims times n_dims matrices of count n_matrices. \n\nOutput:\n\nBenchmarkGroup of package BenchmarkTools comparing the algorithms using diffrent types of test data.\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.ffd-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T<:Real, M<:AbstractMatrix{T}}","page":"Detailed Docs","title":"AJD.ffd","text":"function ffd(A::Vector{M}; <keyword_arguments>) where {T <: Number, M<:AbstractMatrix{T}}\n\nA: Vector of matrices of dimension n  n  k\nthreshold: absolute threshold until calculation should stop. default is eps().\nrel_threshold`: relative threshold for stopping calculation. default is 1e-3.\nmax_iter: max number of iterations. default is 100.\nnorm_: norm by which the update matrix is divided by. can either be :frobenius or :inf. default is :frobenius\nθ: normation criterion. should be smaller than 1. default is 0.99. See paper on ffdiag for more information.\n\n*plot_convergence: whether the convergence plot should be shown or not. default is false.\n\ninitial_guess: is the matrix by which the matrices can be diagonalized. if close to the solution the calculation gets faster. \n\ndefault is identity matrix with size n  n.\n\nCalculates the diagonalization of a set of matrices proposed in 2.\n\nMight be faster than the jade algorithms for certain matrices if initial guess is close to the diagonalized solution.\n\nWon't work if input A is of size n  n  1 since this will lead to NaN values due to  how the update matrix is calculated or if all of the entries of A are the same or have the  same symmetric offdiagonal elements.\n\nWill lead to a warning and stops the calculation.\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.frobenius_offdiag_norm-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T<:Number","page":"Detailed Docs","title":"AJD.frobenius_offdiag_norm","text":"frobenius_offdiag_norm(A::AbstractArray{T,3})::Real where {T<:Number}\n\nA: Vector of matrices with sizen × n × k`\n\nTakes the offdiagonal elements of an Array of matrices A^k and applies the frobenius norm (sum a_ij^2).\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.get_diag_elements-Tuple{Array{<:Number, 3}}","page":"Detailed Docs","title":"AJD.get_diag_elements","text":"get_diag_elements(A::Array)\n\nA: Vector of matrices\n\nTakes an array of matrices and returns the diagonal elements as a diagonal matrix D.\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.get_diagonalization-Tuple{Vector{<:AbstractMatrix{<:Number}}}","page":"Detailed Docs","title":"AJD.get_diagonalization","text":"get_diagonalization(\n    A::Vector{<:AbstractMatrix{<:Number}};\n    algorithm::AbstractDiagonalization = JDiagGabrielDernbach(),\n    max_iter::Int = 1000,\n    threshold::AbstractFloat = eps(),\n    only_plot::Symbol = :no_plot\n    )\n\nGet the actual diagonalization. Function is seperated from diagonalize() to facilitate plotting functionality in the REPL and Pluto. All implemented algorithms are called from this function. To generate the error histories of the algorithm runs, as used for the plots, select only_plot=:plot. Input is checked here as well.\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.get_offdiag_elements-Tuple{Array{<:Number, 3}}","page":"Detailed Docs","title":"AJD.get_offdiag_elements","text":"get_offdiag_elements(A::Array{<:Number,3})\n\nA: Vector of matrices\n\nTakes an array of matrices and returns the offdiagonal elements of A.\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.get_y_fdiag-Tuple{AbstractArray{<:Number}, AbstractArray{<:Number}, Int64, Int64}","page":"Detailed Docs","title":"AJD.get_y_fdiag","text":"get_y_fdiag(D::AbstractArray{<:Number}, E::AbstractArray{<:Number}, i::Int, j::Int)\n\nD: Diagonal Matrix with offdiagonal elements set to zero\nE: Diagonal Matrix with diagonal elements set to zero\ni,j: Denotes the indexes of the matrices D and E\n\nCalculates the factor y_ij which is defined by: _k D_jj^kE_ji^k\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.get_z_fdiag-Tuple{AbstractArray{<:Number}, Int64, Int64}","page":"Detailed Docs","title":"AJD.get_z_fdiag","text":"get_z_fdiag(D::AbstractArray{<:Number}, i::Int, j::Int)\n\nD: Diagonal Matrix with offdiagonal elements set to zero\ni,j: Denotes the indexes of matrix D\n\nCalculates the factor z_ij which is defined by: _k D_ii^kD_jj^k\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.is_commuting-Tuple{AbstractMatrix, AbstractMatrix}","page":"Detailed Docs","title":"AJD.is_commuting","text":"is_commuting(A::AbstractMatrix, B::AbstractMatrix)\n\nA: AbstractMatrix of dimension n  n\nB: AbstractMatrix of dimension n  n\n\nCheck if two matrices A, B are commuting.  AB = BA must hold.\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.jdiag_cardoso-Tuple{Vector{<:AbstractMatrix{<:Real}}, Real}","page":"Detailed Docs","title":"AJD.jdiag_cardoso","text":"jdiag_cardoso(M,threshhold,max_iter = 800)\n\nOnly works for matrix with real valued entries. Based on Matlab Code by Cardoso.\n\nA: a m  m  n matrix,(A_1A_n), each with dimension m  m\nthresh: absolute threshold for approximation stops.default is 10e-8.\n\n*max_iter: number of iterations before algorithm stops. default is 800.\n\nOutput:\n\nV : is a  m  m matrix, which accumulates givens rotations G in each iteration.\nA : is a m  m  n matrix, which contains [VA_1V,...,VA_nV]\niter: accumulates the iteration numbers\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.jdiag_edourdpineau-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T<:Number, M<:AbstractMatrix{T}}","page":"Detailed Docs","title":"AJD.jdiag_edourdpineau","text":"jdiag_edourdpineau(X::Vector{M}; iter=100, eps=1e-3)\n    where {T<:Union{Real,Complex},M<:AbstractMatrix{T}}\n\n*X Diagonalize a set of matrices using the Jacobi method (\"Jacobi Angles for Simultaneous Diagonalization\"). Code adapted from Edouardpineaus Python implementation\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.jdiag_gabrieldernbach!-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T<:Real, M<:AbstractMatrix{T}}","page":"Detailed Docs","title":"AJD.jdiag_gabrieldernbach!","text":"(1) jdiag_gabrieldernbach(A::Vector{Matrix{Float64}}; \n    threshold = eps(), max_iter = 1000)\n\nJDiag algorithm based on the implementation by Gabrieldernbach in Python.\n\nSource: Algorithm\n\n(2) jdiag_gabrieldernbach(A::Vector{Matrix{ComplexF64}}; \n    threshold = eps(), max_iter = 1000)\n\nJDiag algorithm for complex matrices based on the implementation by Gabrieldernbach in Python, the Cardoso Paper and the code  of Algorithm\n\n\n\n\n\n","category":"method"},{"location":"detailed-docs/#AJD.random_normal_commuting_matrices-Tuple{Int64, Int64}","page":"Detailed Docs","title":"AJD.random_normal_commuting_matrices","text":"random_normal_commuting_matrices(n::Int, m::Int; complex::Bool=false)\n\nGenerate m random normal commuting matrices of size n  n These can be exactly diagonalized\n\nM_i M_j = M_j  M_i for all i,j M_i M_i = M_i M_i for all i\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"CurrentModule = AJD","category":"page"},{"location":"getting-started/#Getting-Started-Guide","page":"Getting Started","title":"Getting Started Guide","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This guide provides information on the basic and more advanced usage of the AJD.jl package.","category":"page"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"To install the Package follow these instructions to add the package to a basic Julia environment or use the package in a Pluto notebook.","category":"page"},{"location":"getting-started/#Julia","page":"Getting Started","title":"Julia","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Create temporary environment in the Julia REPL:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"] activate --temp","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Add the package:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"] add https://github.com/muehlefeldt/AJD.jl","category":"page"},{"location":"getting-started/#Pluto","page":"Getting Started","title":"Pluto","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The use in Pluto notebooks is supported. Add the package in one cell of the notebook:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"begin\n    using Pkg\n    Pkg.activate(\"MyTestEnv\")\n    Pkg.add(url=\"https://github.com/muehlefeldt/AJD.jl\")\n    using AJD\nend","category":"page"},{"location":"getting-started/#Basic-usage","page":"Getting Started","title":"Basic usage","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The most basic usage of the package given a vector M of k square matrices (n times n):","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using AJD\nfilter = diagonalize(M)","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The returned object filter of diagonalize() is a LinearFilter containing the matrix F as well as F. Assuming A in M these are used to diagonalize A by calculating D = F A  F. D being the diagonalized matrix. In Julia you calculate:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"D = filter.iF * A * filter.F","category":"page"},{"location":"getting-started/#Advanced-options","page":"Getting Started","title":"Advanced options","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The main function diagonalize() provides several options to be choosen by the user.","category":"page"},{"location":"getting-started/#Algorithms","page":"Getting Started","title":"Algorithms","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The package allows to choose different algorithms to calculate the AJD.","category":"page"},{"location":"getting-started/#JDiag","page":"Getting Started","title":"JDiag","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Further reading on the ins and outs of the \"JDiag\" or \"Jade\" algorithm proposed be J.F. Cardoso can be found in reference [1].","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Three implementations of the JDiag algorithm are available: JDiagCardoso(), JDiagGabrielDernbach() and JDiagEdourdPineau().","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The Cardoso implementation is based on Matlab Code by Cardoso. Use the keyword algorithm = JDiagCardoso().\nBased on a Python implementation by Gabrieldernbach the second implementation is suitable for matrices consisting of real and complex values. Use the keyword algorithm = JDiagGabrielDernbach().\nThe third implementation of JDiag is based on the Python code by Edouard Pineau also supports real and complex matrices, as well as hermitian matrices included in the module LinearAlgebra.jl, which are used in the Diagonalizations.jl package too. This implementation is currently the standard algorithm for the diagonalize() function. Use the keyword algorithm = JDiagEdourdPineau().","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For example execute to execute :","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using AJD\n\n# Generate 1000 exactly diagonalizable matrices of 10 x 10 size.\nM = AJD.get_test_data(:exact_diag, n_dims=10, n_matrices=1000)\n\n# Diagonalize M using selected algorithm.\ndiagonalize(M, algorithm=JDiagEdourdPineau())","category":"page"},{"location":"getting-started/#FFDiag","page":"Getting Started","title":"FFDiag","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"One implementation of the FFDiag algorithm is available through the keyword algorithm = FFDiag(). Resources on the topic can be found under reference [2].","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If you want to use the FFDiag algorithm for calculation of the diagonalization be aware, that a set containing the same matrices, only one matrix or having the same elements on the offdiagonal symmetrical entries can't be calculated using the FFDiag algorithm. NaN values would occur when calculating the update matrix and the algorithm will return the identity matrix as a filter. If you want to calculate those sets refer to the JDiag implementations.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For a minimal example execute:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using AJD\n\n# Generate 1000 exactly diagonalizable matrices of 10 x 10 size.\nM = AJD.get_test_data(:exact_diag, n_dims=10, n_matrices=1000)\n\n# Diagonalize M using selected algorithm.\ndiagonalize(M, algorithm=FFDiag())","category":"page"},{"location":"getting-started/#Plotting","page":"Getting Started","title":"Plotting","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Visual feedback is optionally available. Plots of the convergence behaviour of the used algorithm, heatmaps of the filter matrix as well as the diagonalized matrices can be visualized using the symbol :plot.  The diagonalized matrices D_k are summarised and only overlineD_k is plotted to provide an overview. ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"To generate a plot use diagonalize(M, :plot). Example code to generate a plot:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using AJD\nusing Plots\n\n# Generate 200 exactly diagonalizable matrices of 50 x 50 size.\nM = AJD.get_test_data(:exact_diag, n_dims=50, n_matrices=200)\n\n# Diagonalize M and generate plot.\ndiagonalize(M, :plot, algorithm=FFDiag())","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The generated plot:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"getting-started/#Note","page":"Getting Started","title":"Note","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The plotting functionality is implemented as an extension to AJD.jl. This may require you to add the Plots.jl package to your Julia parent environment to use. This is done limit the dependency footprint of AJD.jl.","category":"page"},{"location":"getting-started/#Benchmarking","page":"Getting Started","title":"Benchmarking","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"An integrated benchmarking of the Jade and FFDiag algorithms is also available. Use diagonalize() with symbol :benchmark and specify the desired size matrices and number matrices. Large input sizes require a lot of computation time due to repeated execution. The algorithms are benchmarked using diffrent types of test data: exactly diagonalizable matrices, diagonalizable matrices and fully random matrices. Example code:","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using AJD\nusing BenchmarkTools\n\n# Using matrices of size 10 x 10. Use 1000 random matrices for each benchmarked run.\ndiagonalize(:benchmark, 10, 1000)","category":"page"},{"location":"getting-started/#Note-2","page":"Getting Started","title":"Note","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The benchmarking functionality as well is implemented as an extension to AJD.jl. This may require you to add the BenchmarkTools package to your Julia parent environment. This is done limit the dependency footprint of AJD.jl as well.","category":"page"},{"location":"getting-started/#Dependency-on-[Diagonalizations.jl](https://marco-congedo.github.io/Diagonalizations.jl/dev/)","page":"Getting Started","title":"Dependency on Diagonalizations.jl","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The package works with the LinearFilter object of Diagonalizations.jl for further integration into the Diagonalizations.jl package if so desired. Furthermore, the LinearFilter gives rise to testing of the algorithms with functions like nonDiagonality provided as part of the package.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"[1] J.-F. Cardoso and A. Souloumiac, \"Jacobi Angles for Simultaneous Diagonalization\", SIAM Journal on Matrix Analysis and Applications, vol. 17, no. 1, pp. 161-164. 1996. doi:10.1137/S0895479893259546.","category":"page"},{"location":"references/","page":"References","title":"References","text":"[2] A. Ziehe, P. Laskov, G. Nolte, K.-R. Müller, \"A Fast Algorithm for Joint Diagonalization with Non-orthogonal Transformations and its Application to Blind Source Separation\", Journal of Machine Learning Research, vol. 5, pp. 777-800. 07, 2004. Published: jmlr.org","category":"page"},{"location":"references/","page":"References","title":"References","text":"For further code examples and references please refer to the task document detailing the project.","category":"page"},{"location":"theoretical-background/#Theoretical-Background","page":"Theory","title":"Theoretical Background","text":"","category":"section"},{"location":"theoretical-background/","page":"Theory","title":"Theory","text":"This module implements Approximate Joint Diagonalization (AJD) of multiple matrices.","category":"page"},{"location":"theoretical-background/#Problem-Statement","page":"Theory","title":"Problem Statement","text":"","category":"section"},{"location":"theoretical-background/","page":"Theory","title":"Theory","text":"The problem of Approximate Joint Diagonalaziation is to find a Matrix V that \"maximally diagonalizes\" as set of matrices C_1 C_2 ldots C_n. This problem of Joint Diagonalization occurs in various data analysis problems, such as blind source separation and independent component analysis. The matrices C_i are typically covariance matrices, which means they are real and symmetric positive semi-definite.","category":"page"},{"location":"theoretical-background/","page":"Theory","title":"Theory","text":"In the special case where all matrices commute pairwise (C_iC_j = C_jC_i for all ij), an exact joint diagonalization exists. However, in practical applications like blind source separation and independent component analysis, this is rarely the case.","category":"page"},{"location":"theoretical-background/#Mathematical-Formulation","page":"Theory","title":"Mathematical Formulation","text":"","category":"section"},{"location":"theoretical-background/","page":"Theory","title":"Theory","text":"The problem can be formally stated as an optimization problem:","category":"page"},{"location":"theoretical-background/","page":"Theory","title":"Theory","text":"V = undersetV neq 0operatornameargmin sum_i=1^n textoff(V^T C_i V)","category":"page"},{"location":"theoretical-background/","page":"Theory","title":"Theory","text":"where textoff(M) represents the sum of squares of the off-diagonal elements of matrix M:","category":"page"},{"location":"theoretical-background/","page":"Theory","title":"Theory","text":"textoff(M) = sum_i neq j m_ij^2","category":"page"},{"location":"theoretical-background/","page":"Theory","title":"Theory","text":"We require the condition that Vneq 0 to avoid the trivial solution of V=0.","category":"page"},{"location":"theoretical-background/#Implementation","page":"Theory","title":"Implementation","text":"","category":"section"},{"location":"theoretical-background/","page":"Theory","title":"Theory","text":"This module provides two distinct algorithms to solve the AJD problem:","category":"page"},{"location":"theoretical-background/","page":"Theory","title":"Theory","text":"JADE (Jacobi Angles for Simultaneous Diagonalization)\nFFDIAG (Fast Frobenius Diagonalization)","category":"page"},{"location":"theoretical-background/#References","page":"Theory","title":"References","text":"","category":"section"},{"location":"theoretical-background/","page":"Theory","title":"Theory","text":"Please refere to References for further literature and sources.","category":"page"},{"location":"testdata_generation/#Generating-(time-correlated)-matrices","page":"Test Data Generation","title":"Generating (time correlated) matrices","text":"","category":"section"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"When generating testdata currently several options are available. Firstly the easiest solution is the function:","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"using AJD\ndata = AJD.get_test_data(:exact_diag, n_dims = 10, n_matrices = 10)\nfilter_ = diagonalize(data, algorithm = FFDiag())","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"which will create a set of 10 matrices, which are normal and commuting with dimension 10 times 10 and calculate the filter containing V. Instead of FFDiag() algorithm JDiagEdourdPineau() or all other algorithms can be used (see getting started).","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"If you want to generate time correlation matrices from a testset the extension AJDExtTimedTestdata is currently available using:","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"using AJD\nusing WAV\ndata = AJD.get_test_data(:approx_diag,\"\")\nfilter_ = diagonalize(data, algorithm = FFDiag())","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"which will create a time delayed correlation matrix with 3 measurement signals from the file channels3_room69_mix.wav, which can be found in the test_data folder and diagonalizes the set of matrices from the correlation matrix. The matrix in data has dimension 5 times 10.","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"For larger testdata the :approx_diag_large symbol can be used.","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"Implementation of the time delayed correlation matrices used are explained here (p.16).","category":"page"},{"location":"testdata_generation/#Note","page":"Test Data Generation","title":"Note","text":"","category":"section"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"The testdata functionality as well is implemented as an extension to AJD.jl. This may require you to add the WAV package to your Julia parent environment. This is done to limit the dependency footprint of AJD.jl.","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"Another way to generate a testset of correlation matrices from random vectors is provided with:","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"using AJD\nusing WAV\n#you can adjust this!\nno_of_signals,no_of_samples = (10,1000)\n#get extension to generate signal\next = Base.get_extension(AJD,:AJDExtTimedTestdata)\nmeas = ext.generate_random_measurements(no_of_signals,no_of_samples)\ntestset_data = ext.generate_testdata(meas, delay = 10,no_of_segments=11,show_warning = false)\nfilter_ = diagonalize(testset_data)","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"which generates random time correlated matrices. See documentation of generate_testdata for further information about the keywords. Currently the delay has to be smaller or equal to the elements in a segment e.g. if no_of_segments is 10 and data has thousand elements maximum delay is 100.","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"For more advanced testdata generation the following might be interesting.","category":"page"},{"location":"testdata_generation/#Further-information-on-generate_testdata","page":"Test Data Generation","title":"Further information on generate_testdata","text":"","category":"section"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"For realising discrete test data the files channels2_room69_mix.wav, channels3_room69_mix.wav and  channels3_room69_mix_shortened.wav are included in the repository. You can load them into the get_test_data function by specifying the absolute path to the file and :exact_diag_large as the symbol. Might however not work when working from the temporary env.","category":"page"},{"location":"testdata_generation/#Generating-testset-from-[https://github.com/fakufaku/bss*speech*dataset](https://github.com/fakufaku/bss_speech_dataset)","page":"Test Data Generation","title":"Generating testset from https://github.com/fakufaku/bssspeechdataset","text":"","category":"section"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"The data was generated using the github code found here.","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"If you want to generate your own test data or additional datasets refer to the github repository linked above and clone it. You'll need python!","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"For the code of the repo to work the following adaptations have to be made:","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"the generate_samples.py has to be changed on line 120. Change the deprecated np.floatto float","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"The generation will take a while and (probably) uses around 10GB of storage space. You can always cancel the generation of testdata during the process and get some testsets generated until then. After generating your testset you might want to edit the soundfiles since some of the testsets have ","category":"page"},{"location":"testdata_generation/#Known-Issues","page":"Test Data Generation","title":"Known Issues","text":"","category":"section"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"The calculation of time correlation matrices won't work if one of the segments is a vector of only zeros, since the correlation of this vector will become NaN due to the variance being zero! The function will throw an error in that case!","category":"page"},{"location":"testdata_generation/","page":"Test Data Generation","title":"Test Data Generation","text":"Make sure to decrease number of segments to counteract.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AJD","category":"page"},{"location":"#AJD.jl-Documentation","page":"Home","title":"AJD.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the AJD.jl Julia Package to perform Approximate Joint Diagonalization (AJD) on multiple matrices.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Getting Started Guide\nDetailed documentation\nTheory\nTest Data Generation\nReferences","category":"page"},{"location":"#Main-AJD.jl-function","page":"Home","title":"Main AJD.jl function","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Below the main function of the AJD.jl package diagonlaize() is introduced. For the entire documentation, including non exported functions, of the package refer to the detailed docs page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"diagonalize(\n        A::Vector{<:AbstractMatrix{<:Number}};\n        algorithm::String = \"jdiag_gabrieldernbach\",\n        max_iter::Int = 1000,\n        threshold::AbstractFloat = eps(),\n        plot_matrix::Bool = false,\n        plot_convergence::Bool = false\n        )","category":"page"},{"location":"#AJD.diagonalize-Tuple{Vector{<:AbstractMatrix{<:Number}}}","page":"Home","title":"AJD.diagonalize","text":"(1)\n    diagonalize(\n        M::Vector{<:AbstractMatrix{<:Number}};\n        algorithm::AbstractDiagonalization = JDiagEdourdPineau(),\n        max_iter::Int = 1000,\n        threshold::AbstractFloat = eps())\n\n\n    (2) diagonalize(\n        M::Vector{<:AbstractMatrix{<:Number}},\n        only_plot::Symbol;\n        algorithm::AbstractDiagonalization = JDiagGabrielDernbach(),\n        max_iter::Int = 1000,\n        threshold::AbstractFloat = eps())\n\n\n    (3) diagonalize(\n        benchmark::Symbol,\n        n_dims::Int,\n        n_matrices::Int)\n\nCalculate joint diagonalization of multiple input matrices M_k.\n\nMain function of the AJD package. Implemented algorithms are JDiag and FFDiag. Input of matrices M_k need to be a vector of matrices. The matrices can be of types Float64 or Complex.\n\nSee the Getting Started Guide for information on the algorithms.\n\nDispatch (1)\n\nInputs:\n\nM: Vector of matrices (requiered).\nalgorithm: Selected algorithm from JDiagGabrielDernbach(), JDiagEdourdPineau(), JDiagCardoso() or FFDiag().\nmax_iter: Maximum iteration step as integer.\nthreshold: Desired threshold minimizing the off-diagonal elements.\n\nOutput:\n\nReturn LinearFilter object. Filter fil contains filter matrix fil.F and the inverse fil.iF.\n\nDispatch (2) - Benchmark Extension to AJD.jl\n\nInputs:\n\nAdditional symbol used to generate overview plot of the result. Use diagonalize(M, :plot).\n\nOutput:\n\nOverview plot. Shows heatmap of the filter matrix, heatmap of the mean of the diagonalized matrices and the vonvergence behaviour of the algorithm.\n\nDispatch (3) - Benchmark Extension to AJD.jl\n\nInputs:\n\nSymbol :benchmark used as diagonalize(:benchmark, 10, 10).\nAutomatic benchmark is run comparing JDiag and FFDiag algorithms. Using n_dims times n_dims matrices of count n_matrices. \n\nOutput:\n\nBenchmarkGroup of package BenchmarkTools comparing the algorithms using diffrent types of test data.\n\n\n\n\n\n","category":"method"}]
}
