<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Detailed Docs · AJD.jl</title><meta name="title" content="Detailed Docs · AJD.jl"/><meta property="og:title" content="Detailed Docs · AJD.jl"/><meta property="twitter:title" content="Detailed Docs · AJD.jl"/><meta name="description" content="Documentation for AJD.jl."/><meta property="og:description" content="Documentation for AJD.jl."/><meta property="twitter:description" content="Documentation for AJD.jl."/><meta property="og:url" content="https://muehlefeldt.github.io/AJD.jl/detailed-docs/"/><meta property="twitter:url" content="https://muehlefeldt.github.io/AJD.jl/detailed-docs/"/><link rel="canonical" href="https://muehlefeldt.github.io/AJD.jl/detailed-docs/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AJD.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Detailed Docs</a></li><li><a class="tocitem" href="../theoretical-background/">Theory</a></li><li><a class="tocitem" href="../testdata_generation/">Test Data Generation</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Detailed Docs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Detailed Docs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/muehlefeldt/AJD.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/muehlefeldt/AJD.jl/blob/master/docs/src/detailed-docs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Detailed-Docs"><a class="docs-heading-anchor" href="#Detailed-Docs">Detailed Docs</a><a id="Detailed-Docs-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-Docs" title="Permalink"></a></h1><ul><li><a href="#AJD.ALL_ALGORITHMS"><code>AJD.ALL_ALGORITHMS</code></a></li><li><a href="#AJD.addrandomnoise-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Number, M&lt;:AbstractMatrix{T}}"><code>AJD.addrandomnoise</code></a></li><li><a href="#AJD.check_input-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Number}}, Int64, AbstractFloat}"><code>AJD.check_input</code></a></li><li><a href="#AJD.create_linear_filter-Tuple{Matrix{T} where T&lt;:Number}"><code>AJD.create_linear_filter</code></a></li><li><a href="#AJD.diagonalize-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Number}}}"><code>AJD.diagonalize</code></a></li><li><a href="../#AJD.diagonalize-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Number}}}"><code>AJD.diagonalize</code></a></li><li><a href="#AJD.ffd-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Real, M&lt;:AbstractMatrix{T}}"><code>AJD.ffd</code></a></li><li><a href="#AJD.frobenius_offdiag_norm-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Number"><code>AJD.frobenius_offdiag_norm</code></a></li><li><a href="#AJD.get_diag_elements-Tuple{Array{&lt;:Number, 3}}"><code>AJD.get_diag_elements</code></a></li><li><a href="#AJD.get_diagonalization-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Number}}}"><code>AJD.get_diagonalization</code></a></li><li><a href="#AJD.get_offdiag_elements-Tuple{Array{&lt;:Number, 3}}"><code>AJD.get_offdiag_elements</code></a></li><li><a href="#AJD.get_y_fdiag-Tuple{AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}, Int64, Int64}"><code>AJD.get_y_fdiag</code></a></li><li><a href="#AJD.get_z_fdiag-Tuple{AbstractArray{&lt;:Number}, Int64, Int64}"><code>AJD.get_z_fdiag</code></a></li><li><a href="#AJD.is_commuting-Tuple{AbstractMatrix, AbstractMatrix}"><code>AJD.is_commuting</code></a></li><li><a href="#AJD.jdiag_cardoso-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Real}}, Real}"><code>AJD.jdiag_cardoso</code></a></li><li><a href="#AJD.jdiag_edourdpineau-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Number, M&lt;:AbstractMatrix{T}}"><code>AJD.jdiag_edourdpineau</code></a></li><li><a href="#AJD.jdiag_gabrieldernbach!-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Real, M&lt;:AbstractMatrix{T}}"><code>AJD.jdiag_gabrieldernbach!</code></a></li><li><a href="#AJD.random_normal_commuting_matrices-Tuple{Int64, Int64}"><code>AJD.random_normal_commuting_matrices</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.ALL_ALGORITHMS" href="#AJD.ALL_ALGORITHMS"><code>AJD.ALL_ALGORITHMS</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>List of all algorithms. To loop over in tests.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/global_constants.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.addrandomnoise-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Number, M&lt;:AbstractMatrix{T}}" href="#AJD.addrandomnoise-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Number, M&lt;:AbstractMatrix{T}}"><code>AJD.addrandomnoise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addrandomnoise(
    A::Vector{M};
    σ::AbstractFloat = 0.5,
    same_noise::Bool = true,
) where {T&lt;:Number,M&lt;:AbstractMatrix{T}}</code></pre><p>Add ranom noise to a vector of matrices <code>A</code>. If same noise selected same random matrix R used for all (!) matrices. Completley random noise added to each matrix in <code>A</code> with <code>same_noise=false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/utils.jl#L191-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.check_input-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Number}}, Int64, AbstractFloat}" href="#AJD.check_input-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Number}}, Int64, AbstractFloat}"><code>AJD.check_input</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_input(
    A::Vector{&lt;:AbstractMatrix{&lt;:Number}},
    max_iter::Int,
    threshold::AbstractFloat,
    )</code></pre><p>Check input of diagonalize(). Validate matrices, threshold and max iteration as selected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/utils.jl#L142-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.create_linear_filter-Tuple{Matrix{T} where T&lt;:Number}" href="#AJD.create_linear_filter-Tuple{Matrix{T} where T&lt;:Number}"><code>AJD.create_linear_filter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create <a href="https://marco-congedo.github.io/Diagonalizations.jl/dev/Diagonalizations/#LinearFilter">LinearFilter</a> object as introduced by <a href="https://marco-congedo.github.io/Diagonalizations.jl/dev/">Diagonalizations.jl</a>. Output of AJD.jl follows convention of Diagonalizations.jl and produces a LinearFilter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/utils.jl#L45-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.diagonalize-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Number}}}" href="#AJD.diagonalize-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Number}}}"><code>AJD.diagonalize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1)
    diagonalize(
        M::Vector{&lt;:AbstractMatrix{&lt;:Number}};
        algorithm::AbstractDiagonalization = JDiagEdourdPineau(),
        max_iter::Int = 1000,
        threshold::AbstractFloat = eps(),
    )

(2)
    diagonalize(
        M::Vector{&lt;:AbstractMatrix{&lt;:Number}},
        only_plot::Symbol;
        algorithm::AbstractDiagonalization = JDiagGabrielDernbach(),
        max_iter::Int = 1000,
        threshold::AbstractFloat = eps(),
    )

(3)
    diagonalize(
        benchmark::Symbol,
        n_dims::Int,
        n_matrices::Int,
    )</code></pre><p>Calculate joint diagonalization of multiple input matrices <span>$M_k$</span>.</p><p>Main function of the AJD package. Implemented algorithms are JDiag and FFDiag. Input of matrices <span>$M_k$</span> need to be a vector of matrices. The matrices can be of types Float64 or Complex.</p><p>See the <a href="https://muehlefeldt.github.io/AJD.jl/dev/getting-started/">Getting Started Guide</a> for information on the algorithms.</p><p><strong>Dispatch (1)</strong></p><p>Inputs:</p><ul><li><code>M</code>: Vector of matrices (requiered).</li><li><code>algorithm</code>: Selected algorithm from <code>JDiagGabrielDernbach()</code>, <code>JDiagEdourdPineau()</code>, <code>JDiagCardoso()</code> or <code>FFDiag()</code>.</li><li><code>max_iter</code>: Maximum iteration step as integer.</li><li><code>threshold</code>: Desired threshold minimizing the off-diagonal elements.</li></ul><p>Output</p><ul><li>Return LinearFilter object. Filter <code>fil</code> contains filter matrix <code>fil.F</code> and the inverse <code>fil.iF.</code></li></ul><p><strong>Dispatch (2) - Benchmark Extension to AJD.jl</strong></p><p>Inputs:</p><ul><li>Additional symbol used to generate overview plot of the result. <code>Use diagonalize(M, :plot)</code>.</li></ul><p>Output</p><ul><li>Overview plot. Shows heatmap of the filter matrix, heatmap of the mean of the diagonalized matrices and the vonvergence behaviour of the algorithm.</li></ul><p><strong>Dispatch (3) - Benchmark Extension to AJD.jl</strong></p><p>Inputs:</p><ul><li>Symbol <code>:benchmark</code> used as <code>diagonalize(:benchmark, 10, 10)</code>.</li><li>Automatic benchmark is run comparing JDiag and FFDiag algorithms. Using <code>n_dims</code> <span>$\times$</span> <code>n_dims</code> matrices of count <code>n_matrices.</code> </li></ul><p>Output</p><ul><li>BenchmarkGroup of package <code>BenchmarkTools</code> comparing the algorithms using diffrent types of test data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/AJD.jl#L29-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.ffd-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Real, M&lt;:AbstractMatrix{T}}" href="#AJD.ffd-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Real, M&lt;:AbstractMatrix{T}}"><code>AJD.ffd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function ffd(A::Vector{M}; &lt;keyword_arguments&gt;) where {T &lt;: Number, M&lt;:AbstractMatrix{T}}</code></pre><p>*<code>A</code>: Vector of matrices of dimension <span>$n × n × k$</span></p><p>*<code>threshold</code>: absolute threshold until calculation should stop. default is eps().</p><p>*rel_threshold: relative threshold for stopping calculation. default is 1e-3.</p><p>*<code>max_iter</code>: max number of iterations. default is 100.</p><p>*<code>norm_</code>: norm by which the update matrix is divided by. can either be :frobenius or :inf. default is :frobenius</p><p>*<code>θ</code>: normation criterion. should be smaller than 1. default is 0.99. See paper on <a href="https://www.jmlr.org/papers/volume5/ziehe04a/ziehe04a.pdf">ffdiag</a> for more information.</p><p>*<code>plot_convergence</code>: whether the convergence plot should be shown or not. default is false.</p><p>*<code>initial_guess</code>: is the matrix by which the matrices can be diagonalized. if close to the solution the calculation gets faster. default is identity matrix with size <span>$n × n$</span>.</p><p>Calculates the diagonalization of a set of matrices proposed in <a href="https://www.jmlr.org/papers/volume5/ziehe04a/ziehe04a.pdf">2</a>.  Might be faster than the jade algorithms for certain matrices if initial guess is close to the diagonalized solution.</p><p>Won&#39;t work if input <code>A</code> is of size <span>$n × n × 1$</span> since this will lead to NaN values due to how the update matrix is calculated or if all of the entries of <code>A</code> are the same. Will lead to a warning and stops the calculation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/FFDiag.jl#L2-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.frobenius_offdiag_norm-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Number" href="#AJD.frobenius_offdiag_norm-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Number"><code>AJD.frobenius_offdiag_norm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">frobenius_offdiag_norm(A::AbstractArray{T,3})::Real where {T&lt;:Number}</code></pre><ul><li>A: Vector of matrices with size <span>$n × n × k$</span></li></ul><p>Takes the offdiagonal elements of an Array of matrices <span>$A^k$</span> and applies the frobenius norm (<span>$\sum |a_{i,j}|^{2}$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/utils.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.get_diag_elements-Tuple{Array{&lt;:Number, 3}}" href="#AJD.get_diag_elements-Tuple{Array{&lt;:Number, 3}}"><code>AJD.get_diag_elements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_diag_elements(A::Array)</code></pre><ul><li>A: Vector of matrices</li></ul><p>Takes an array of matrices and returns the diagonal elements as a diagonal matrix D.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/utils.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.get_diagonalization-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Number}}}" href="#AJD.get_diagonalization-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Number}}}"><code>AJD.get_diagonalization</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_diagonalization(
    A::Vector{&lt;:AbstractMatrix{&lt;:Number}};
    algorithm::AbstractDiagonalization = JDiagGabrielDernbach(),
    max_iter::Int = 1000,
    threshold::AbstractFloat = eps(),
    only_plot::Symbol = :no_plot
    )</code></pre><p>Get the actual diagonalization. Function is seperated from <code>diagonalize()</code> to facilitate plotting functionality in the REPL and Pluto. All implemented algorithms are called from this function. To generate the error histories of the algorithm runs, as used for the plots, select <code>only_plot=:plot</code>. Input is checked here as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/utils.jl#L225-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.get_offdiag_elements-Tuple{Array{&lt;:Number, 3}}" href="#AJD.get_offdiag_elements-Tuple{Array{&lt;:Number, 3}}"><code>AJD.get_offdiag_elements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_offdiag_elements(A::Array{&lt;:Number,3})</code></pre><ul><li>A: Vector of matrices</li></ul><p>Takes an array of matrices and returns the offdiagonal elements of A.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/utils.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.get_y_fdiag-Tuple{AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}, Int64, Int64}" href="#AJD.get_y_fdiag-Tuple{AbstractArray{&lt;:Number}, AbstractArray{&lt;:Number}, Int64, Int64}"><code>AJD.get_y_fdiag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_y_fdiag(D::AbstractArray{&lt;:Number}, E::AbstractArray{&lt;:Number}, i::Int, j::Int)</code></pre><ul><li>D: Diagonal Matrix with offdiagonal elements set to zero</li><li>E: Diagonal Matrix with diagonal elements set to zero</li><li>i,j: Denotes the indexes of the matrices D and E</li></ul><p>Calculates the factor <span>$y_{ij}$</span> which is defined by: <span>$∑_{k} D_{j,j}^{k}E_{j,i}^{k}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/utils.jl#L129-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.get_z_fdiag-Tuple{AbstractArray{&lt;:Number}, Int64, Int64}" href="#AJD.get_z_fdiag-Tuple{AbstractArray{&lt;:Number}, Int64, Int64}"><code>AJD.get_z_fdiag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_z_fdiag(D::AbstractArray{&lt;:Number}, i::Int, j::Int)</code></pre><ul><li>D: Diagonal Matrix with offdiagonal elements set to zero</li><li>i,j: Denotes the indexes of matrix D</li></ul><p>Calculates the factor <span>$z_{ij}$</span> which is defined by: <span>$∑_{k} D_{i,i}^{k}D_{j,j}^{k}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/utils.jl#L118-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.is_commuting-Tuple{AbstractMatrix, AbstractMatrix}" href="#AJD.is_commuting-Tuple{AbstractMatrix, AbstractMatrix}"><code>AJD.is_commuting</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_commuting(A::AbstractMatrix, B::AbstractMatrix)</code></pre><ul><li>A: AbstractMatrix of dimension <span>$n × n$</span></li><li>B: AbstractMatrix of dimension <span>$n × n$</span></li></ul><p>Check if two matrices A, B are commuting.  <span>$AB = BA$</span> must hold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/utils.jl#L105-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.jdiag_cardoso-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Real}}, Real}" href="#AJD.jdiag_cardoso-Tuple{Vector{&lt;:AbstractMatrix{&lt;:Real}}, Real}"><code>AJD.jdiag_cardoso</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jdiag_cardoso(M,threshhold,max_iter = 800)</code></pre><p>Only works for matrix with real valued entries. Based on <a href="https://www2.iap.fr/users/cardoso/jointdiag.html">Matlab Code by Cardoso</a>.</p><ul><li><code>A</code>: a <span>$m × m × n$</span> matrix,(<span>$A_1,...,A_n$</span>), each with dimension <span>$m × m$</span></li><li><code>thresh</code>: absolute threshold for approximation stops.default is 10e-8.</li></ul><p>*<span>$max_iter$</span>: number of iterations before algorithm stops. default is 800.</p><p>Output:</p><ul><li>V : is a  <span>$m × m$</span> matrix, which accumulates givens rotations G in each iteration.</li><li>A : is a <span>$m × m × n$</span> matrix, which contains [<span>$VA_1V&#39;$</span>,...,<span>$VA_nV&#39;$</span>]</li><li>iter: accumulates the iteration numbers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/jdiag_algorithms/jdiag_cardoso.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.jdiag_edourdpineau-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Number, M&lt;:AbstractMatrix{T}}" href="#AJD.jdiag_edourdpineau-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Number, M&lt;:AbstractMatrix{T}}"><code>AJD.jdiag_edourdpineau</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jdiag_edourdpineau(X::Vector{M}; iter=100, eps=1e-3)
    where {T&lt;:Union{Real,Complex},M&lt;:AbstractMatrix{T}}</code></pre><p>*X Diagonalize a set of matrices using the Jacobi method (&quot;Jacobi Angles for Simultaneous Diagonalization&quot;). Code adapted from <a href="https://github.com/edouardpineau/Time-Series-ICA-with-SOBI-Jacobi">Edouardpineaus Python implementation</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/jdiag_algorithms/jdiag_edourdpineau.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.jdiag_gabrieldernbach!-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Real, M&lt;:AbstractMatrix{T}}" href="#AJD.jdiag_gabrieldernbach!-Union{Tuple{Vector{M}}, Tuple{M}, Tuple{T}} where {T&lt;:Real, M&lt;:AbstractMatrix{T}}"><code>AJD.jdiag_gabrieldernbach!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(1) jdiag_gabrieldernbach(A::Vector{Matrix{Float64}}; 
    threshold = eps(), max_iter = 1000)</code></pre><p>JDiag algorithm based on the implementation by Gabrieldernbach in Python.</p><p>Source: <a href="https://github.com/gabrieldernbach/approximate_joint_diagonalization/blob/master/jade/jade_cpu.py">Algorithm</a></p><pre><code class="nohighlight hljs">(2) jdiag_gabrieldernbach(A::Vector{Matrix{ComplexF64}}; 
    threshold = eps(), max_iter = 1000)</code></pre><p>JDiag algorithm for complex matrices based on the implementation by Gabrieldernbach in Python, the Cardoso Paper and the code  of <a href="https://github.com/edouardpineau/Time-Series-ICA-with-SOBI-Jacobi">Algorithm</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/jdiag_algorithms/jdiag_gabrieldernbach.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AJD.random_normal_commuting_matrices-Tuple{Int64, Int64}" href="#AJD.random_normal_commuting_matrices-Tuple{Int64, Int64}"><code>AJD.random_normal_commuting_matrices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_normal_commuting_matrices(n::Int, m::Int; complex::Bool=false)</code></pre><p>Generate m random normal commuting matrices of size <span>$n × n$</span> These can be exactly diagonalized</p><p><span>$M_i M_j = M_j  M_i$</span> for all i,j <span>$M_i M_i&#39; = M_i&#39; M_i$</span> for all i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/muehlefeldt/AJD.jl/blob/af1e63d94c30a6495b2df97a0794f26eec1d0af3/src/utils.jl#L6-L14">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting-started/">« Getting Started</a><a class="docs-footer-nextpage" href="../theoretical-background/">Theory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 31 January 2025 22:18">Friday 31 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
